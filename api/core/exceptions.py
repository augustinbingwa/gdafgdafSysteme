import logging

from django.db import IntegrityError
from django.core.exceptions import ValidationError as DjangoValidationError
from django.utils.translation import gettext as _

from rest_framework.views import exception_handler
from rest_framework.response import Response
from rest_framework import status

logger = logging.getLogger(__name__)


def core_exception_handler(exc, context):
    # If an exception is thrown that we don't explicitly handle here, we want
    # to delegate to the default exception handler offered by DRF. If we do
    # handle this exception type, we will still want access to the response
    # generated by DRF, so we get that response up front.

    response = exception_handler(exc, context)
    handlers = {
        "NotFound": _handle_not_found_error,
        "ValidationError": _handle_generic_error,
    }
    # This is how we identify the type of the current exception. We will use
    # this in a moment to see whether we should handle this exception or let
    # Django REST Framework do it's thing.
    exception_class = exc.__class__.__name__

    # raise exc

    logger.debug(
        (
            "\n\n=========================================== EXCEPTION =========================================\n"
            "Message : {message}\nFile : {filename}\nLine : {lineno}\nName : {name}\nType: {type}\n"
            "======================================== END EXCEPTION =========================================\n\n"
        ).format(
            # message=dir(exc.__traceback__.tb_frame),
            # message=exc.__traceback__.tb_frame.f_locals,
            message=exc,
            filename=exc.__traceback__.tb_frame.f_code.co_filename,
            lineno=exc.__traceback__.tb_lineno,
            name=exc.__traceback__.tb_frame.f_code.co_name,
            type=exception_class,
        )
    )

    # Some custom exceptions are to be handled separately
    # Eg: IntegrityErron ...
    if isinstance(exc, IntegrityError) and not response:
        response = Response(
            {
                "errors": _(
                    "It seems there is a conflict between the data you are trying to save and your current "
                    "data. Please review your entries and try again."
                ),
                "success": False,
                "response_message": _("Database error"),
                "response_code": "400",
            },
            status=status.HTTP_400_BAD_REQUEST,
        )

    if isinstance(exc, DjangoValidationError) and not response:
        error_dict = getattr(exc, "error_dict", {"errors": _("Invalid data received.")})
        error_dict["success"] = False
        error_dict["response_message"] = _("Invalid data received")
        error_dict["response_code"] = "400"
        response = Response(
            error_dict,
            status=status.HTTP_400_BAD_REQUEST,
        )

    if exception_class in handlers:
        # If this exception is one that we can handle, handle it. Otherwise,
        # return the response generated earlier by the default exception
        # handler.
        return handlers[exception_class](exc, context, response)
    elif not response:
        return Response(
            {
                "errors": "Server or code error. Please check logs.",
                "success": False,
                "response_message": _("An error occured"),
                "response_code": "500",
            },
            status=status.HTTP_500_INTERNAL_SERVER_ERROR,
        )

    return response


def _handle_generic_error(exc, context, response):
    # This is about the most straightforward exception handler we can create.
    # We take the response generated by DRF and wrap it in the `errors` key.
    response.data = {
        "errors": response.data,
        "success": False,
        "response_message": _("An error occured"),
        "response_code": "01",
    }

    return response


def _handle_not_found_error(exc, context, response):
    view = context.get("view", None)

    if view and hasattr(view, "queryset") and view.queryset is not None:
        error_key = view.queryset.model._meta.verbose_name

        response.data = {
            "errors": {error_key: response.data["detail"]},
            "success": False,
            "response_message": _("Not found"),
            "response_code": "404",
        }

    else:
        response = _handle_generic_error(exc, context, response)

    return response
